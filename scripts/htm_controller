#!/usr/bin/env python

from htm.lib.pomdp import GraphPolicyRunner, GraphPolicyBeliefRunner

from htm.task import (HierarchicalTask, AbstractAction, SequentialCombination,
                      LeafCombination)
from htm.task_to_pomdp import CollaborativeAction, HTMToPOMDP
from htm.stool_scenarios import (stool_task_sequential, T_WAIT, T_COMM, C_INTR,
                                C_ERR, INF)

import rospy
from baxter_collaboration.graph_policy_controller import BaseGPController


T_FAKE = 10


class GPController(BaseGPController):

    OBJ = {
        'left-leg': 17,
        'right-leg': 26,
        'central-frame': 24,
        'top': 21,
    }
    PAST = {
        'snap': 'snapped',
        'take': 'taken',
        'get': 'got',
        'hold': 'held',
    }
    GET = 'get'
    PASS = 'pass'
    HOLD = 'hold_start'
    RELEASE = 'hold_end'
    RECOVER_GET = 'recover_get'
    RECOVER_HOLD = 'home'

    def take_action(self, action):
        if action == 'wait':
            return self.action_wait()
        else:
            t, a = action.split('-', 1)
            if t == 'phy':
                return self.action_physical(a)
            elif t == 'com':
                return self.action_communicate(a)
            else:
                raise ValueError('Unknown action: {}'.format(action))

    def action_physical(self, action):
        name, obj = action.split('-', 1)
        rospy.loginfo("Taking action: {} on {}".format(name, obj))
        o = self.OBJ[obj]
        if name in ['bring', 'get']:
            result = self.action_left(self.GET, o).success
            if name == 'bring':
                result = result and self._pass(o)
            rospy.loginfo("received result: " + str(result))
            if result:
                return self.NONE
            else:
                result = self.action_left(self.RECOVER_GET, o)
                if not result:
                    raise RuntimeError("Action 'recover get' failed.")
                return self.ERROR
        elif name == 'hold':
            result = self._prepare_hold(o)
            return self.NONE if result else self.ERROR
        elif name == 'release':
            result = self.action_right(self.RELEASE, o)
            return self.NONE
        elif name == 'snap':
            error = self.error_sub.wait_for_msg(timeout=T_FAKE)
            return self.NO if error else self.NONE
        else:
            raise ValueError('Unkown physical action: {}'.format(name))

    def action_communicate(self, action):
        v, c, a, o = action.split('-', 3)
        sentence = self._get_sentence(c, a, o)
        rospy.loginfo("{}ing: \"{}\"".format(v.capitalize(), sentence))
        ans = self.answer_sub.start_listening()
        self.say(sentence)
        if v == 'ask':
            ans = self.answer_sub.wait_for_msg(continuing=True)
            if ans is None:
                return self.NONE  # Question at wrong time
            elif ans == 'yes':
                if a == 'hold':
                    self._pass(0)
                    self._prepare_hold(0)
                return self.YES
            elif ans == 'no':
                return self.NO
            else:
                raise ValueError('Unknown answer: ' + ans)
        else:
            return self.NONE

    def _get_sentence(self, v, a, o):
        o_name = o.replace('-', ' ')
        if v == 'ask':
            if c == 'intention':
                if a == 'hold':
                    sentence = "Can you move the central frame to my right hand?"
                else:
                    sentence = "Can you {} the {}?".format(a, o_name)
            elif c == 'finished':
                sentence = "Have you {} the {}?".format(self.PAST[a], o_name)
            else:
                raise ValueError('Unknown question')
        elif v == 'tell':
            sentence = "I'm going to {} the {}.".format(a, o_name)

    def _prepare_hold(self, o):
        result = self.action_right(self.HOLD, o).success
        if result:
            return True
        else:
            result = self.action_right(self.RECOVER_HOLD, o)
            if not result:
                raise RuntimeError("Action 'recover hold' failed.")
            return False

    def _pass(self, o):
        result = self.action_left(self.PASS, o).success
        if result:
            return True
        else:
            return False


h2p = HTMToPOMDP(T_WAIT, T_COMM)
p = h2p.task_to_pomdp(stool_task_sequential)
gp = p.solve(method='grid', n_iterations=200)

# TODO remove (DEBUG)
import os
gp.dump_to(os.path.expanduser('~/src/htm/visualization/policy/json/stool.json'))

controller = GPController(GraphPolicyRunner(gp))
controller.run()
